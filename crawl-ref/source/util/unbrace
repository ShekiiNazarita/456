#!/usr/bin/perl -w
use Getopt::Std;

our ($opt_n);
getopts('n');
my $dry_run = $opt_n;
my $any_bad = 0;

my @files = @ARGV;
undef $/;
unless (@files)
{
    @files = (grep /\.(cc|h)$/, split /\n/, `git ls-files`);
}

for $f (@files)
{
    open F, "<", $f or die "Can't read $f\n";
    my $old = $_ = <F>;
    close F;

    # Eliminate braces around one-line blocks.
    s&^( +(?:if|while|for|do|else)\b[^\n]*)\n +{\n( *[^/ }][^\n]*)\n +}$&$1\n$2&msg;

    # Something like the following should match multi-line flow-control
    # statements with missing braces, but:
    #  1. it's slow (for example, on beam.cc);
    #  2. it has false positives at the end of do-while loops; and
    #  3. it's not clear how to determine where to put the braces.
    #
    # /( # Save multi-line statement with missing braces in \1.
    #    # Save indent of first line in \2
    #    ^(\s+)     (?:if|while|for|do|else)\b           .*\n
    #
    #     # Second line: not flow-control, greater indent.
    #     \2 \s+    (?! \s | (?:if|while|for|do|else)\b) .*\n
    #
    #     # One or more lines of greater indent than the first.
    #     (?: \2 \s+ .*\n)+
    #  )
    #  # Next line falls outside the indentation of the first line: it has
    #  # either a smaller indent, or the same indent then a non-brace.
    #  (?! \2 [\s{])
    # /mgx; # No /s !

    # return is not a function, eliminate totally enclosing parentheses.
    # This part handles parenthese-less payloads.
    while (/^( *)return \(([^()]+)\);/sm)
    {
        # Done this roundabout way to properly unindent multiline blocks.
        my $prev = "$`$1return ";
        my $next = ";$'";
        my $cur = $2;
        $cur =~ s/\n /\n/sg;
        $_ = "$prev$cur$next";
    }

    # return (x) where x contains parentheses.
    # Looks like no one told Larry Wall properties of regular expression,
    # including the part where they can't do arbitrarily nested parentheses.
    while (/^(\s*)return\s+
            \((
             (?: [^()]*+
                 (\( (?: [^()]++ | (?3) )* \))
             )+
             [^()]*+
            )\);/sxm)
    {
        my $prev = "$`$1return ";
        my $next = ";$'";
        my $cur = "$2";
        $cur =~ s/\n /\n/sg;
        $_ = "$prev$cur$next";
    }

    if ($old ne $_)
    {
        print "$f\n";
        $any_bad = 1;
        if (!$dry_run)
        {
            open F, ">", $f or die "Can't write $f\n";
            print F;
            close F;
        }
    }
}

exit 1 if ($dry_run and $any_bad);
