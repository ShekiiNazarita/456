#!/usr/bin/perl -w

my $lang;
my @files;

for (@ARGV)
{
    if (/^-v$/)
    {
        $verbose = 1;
    }
    # Hack: no two-letter names are allowed, as these are assumed to be lang.
    elsif (/^([a-z][a-z])$/)
    {
        die "One language at a time, please.\n" if $lang;
        $lang = $1;
    }
    else
    {
        s/\.txt$//;
        die "Arg not a lang nor a filename: '$_'.\n" unless m{^([/a-z0-9_-]+)$}i; #/
        push @files, $1;
    }
}

sub good_file()
{
    return grep { $file =~ m{\b$_\b} } @files;
}

sub err($)
{
    print $_[0];
}

sub __________________________________________________________________________
{
    %entries = (); # per-db
    %source = (); # file:line
    %keys = (); # per-file
}

sub read_file($)
{
    my $skip = !!@files;
    ($file) = @_;
    $skip = 0 if good_file();
    $file =~ s|/|/$lang/| if $lang;
    $skip = 0 if good_file();
    return if $skip;
    $file = "dat/$file.txt";

    %keys = ();
    $line = 0;
    return $lang ? 0 : die "Can't read $file\n" unless open F, "<", $file;
    ($key, $value) = ();
    local $_;

    print "Checking $file\n" if $verbose;
    
    sub add_key()
    {
        err "Duplicate entry: '$key' at $source{$key} and $file:$line\n"
            if $source{$key};
        $source{$key} = "$file:$line";
        $entries{$key} = $value;
        $keys{$key} = 1;

        undef $key;
        undef $value;
    }
    
    while (<F>)
    {
        next if /^#/;
        s/\s+$//;

        if (/^%%%%/)
        {
            add_key() if defined $key;
            next;
        }

        unless (defined $key)
        {
            next if /^$/;
            $key = $_;
            $line = $.; # report the start not end of a desc
        }
        else
        {
            next if /^$/ && !defined $value;
            $value .= $_;
        }
    }

    if (defined $key)
    {
        defined($value)
        ? add_key()
        : err("Incomplete entry '$key' at the end of '$file'\n");
    }

    close F;
    return 1;
}

sub check_db_locals()
{
    my (%locals, %keys);
    $keys{$_}=1 for keys %entries;
    $locals{$_}=1 for map /@(_[^@\n]+_)@/g, values %entries;
    for (sort keys %locals)
    {
        err("Undefined local entry '$_'\n") unless $entries{$_};
        delete $keys{$_};
    }
    err("Unused local entry '$_' at $source{$_}\n") for grep /^_.*_$/, keys %keys;
}

__________________________________________________________________________();
read_file("descript/items");
read_file("descript/unident");
read_file("descript/spells");
read_file("descript/gods");
read_file("descript/skills");
read_file("descript/ability");
read_file("descript/commands");

if (read_file("descript/branches"))
{
    for (`util/gather_branches`)
    {
        chomp;
        err "$file: No description for branch '$_'\n" unless $entries{$_};
        delete $keys{$_};
    }
    err "$file: Unused description for branch '$_'\n" for sort keys %keys;
}

if (read_file("descript/features"))
{
    $entries{"A gate leading to a distant place"} = 1;
    for (`util/gather_features -a`)
    {
        chomp;
        next if /explore horizon$/;
        err "$file: No description for feature '$_'\n" unless $entries{$_};
        delete $keys{$_};
    }
    err "$file: Unused description for feature '$_'\n" for sort keys %keys;
}

if (read_file("descript/unrand"))
{
    for (`grep ^NAME: art-data.txt`)
    {
        chomp;
        s/^NAME:\s+//;
        next if /^DUMMY/;
        err "$file: No description for unrand '$_'\n" unless $entries{$_};
        delete $keys{$_};
    }
    err "$file: Unused description for unrand '$_'\n" for sort keys %keys;
}

if (read_file("descript/cards"))
{
    for (`util/gather_cards`)
    {
        chomp;
        err "$file: No description for card '$_'\n" unless $entries{"$_ card"};
        delete $keys{"$_ card"};
    }
    delete $keys{'a buggy card'};
    delete $keys{'a very buggy card'};
    err "$file: Unused description for card '$_'\n" for sort keys %keys;
}

if (read_file("descript/monsters"))
{
    $entries{$_} = 1 for (
        # described with a suffix
        'the Serpent of Hell',
        # overridden descriptions
        'player', 'player illusion', 'merged slime creature',
        # genus-only monsters
        'ghost', 'giant', 'golem', 'hell lord', 'bear', 'elemental');
    for (`util/gather_mons -d`)
    {
        chomp;
        # using a desc from another file is ok, it's the same db
        err "$file: No description for monster '$_'\n" unless $entries{$_};
        delete $keys{$_}
    }

    delete $keys{'__(_suffix_examine'};
    for (sort keys %keys)
    {
        next if /^__cap-[A-Z]_suffix$/;
        next if /^the Serpent of Hell (?:gehenna|cocytus|dis|tartarus)$/;
        err "$file: Unused description for monster '$_'\n";
    }
}


__________________________________________________________________________();
read_file("descript/$_") for qw(species backgrounds);
__________________________________________________________________________();
read_file("database/$_") for qw(randname rand_wpn rand_arm rand_all randbook monname);
check_db_locals();
__________________________________________________________________________();
read_file("database/$_") for qw(monspeak monspell monflee wpnnoise insult godspeak);
check_db_locals();
__________________________________________________________________________();
read_file("database/$_") for qw(shout insult);
check_db_locals();
__________________________________________________________________________();
read_file("descript/quotes");
__________________________________________________________________________();
read_file("database/help");
__________________________________________________________________________();
read_file("database/FAQ");
