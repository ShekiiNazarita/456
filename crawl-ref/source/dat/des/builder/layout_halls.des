###############################################################################
# layout_caves.des: Layouts based on cavelike formations, largely using
#                   procedural noise functions
###############################################################################

: require("dlua/util.lua")
: require("dlua/layout/procedural.lua")
: require("dlua/layout/zonify.lua")

NAME:   layout_wheels
DEPTH:  Zot,Snake
WEIGHT: 20
ORIENT: encompass
TAGS: overwritable layout allow_dup unrand
{{
  layout_type "halls"
  if is_validating() then return; end
  local gxm,gym = dgn.max_bounds()

  -- TODO:
  --  * Properly implement the gaps (including regular / chaotic position and sizing)
  --  * Chop the corridors up instead of drawing gaps. Link everything together using zoning once it's implemented,
  --    for now just use some Worley paths.
  --  * Maybe ruin some walls
  --  * Maybe 2 rings isn't enough and should be rarer/non-existing (and can we get away with more than 6?)
  --  * Tune params a bit for Snake

  local fcircle
  if crawl.coinflip() then
    fcircle = procedural.distance { radius = math.min(gxm,gym)/2 - 2, origin = { x = gxm/2, y = gym/2 } }
  else
    fcircle = procedural.box { x1 = 1, y1 = 1, x2 = gxm-2, y2 = gym-2 }
  end
  local frad = procedural.radial { origin = { x = gxm/2, y = gym/2 } }
  local wall_break = util.random_range_real(.3,.7)
  local rings = crawl.random_range(2,6)
  -- We need at least one hole in each partitioning wall
  local ring_holes = {}
  local hole_size = util.random_range_real(0.1,0.6) -- 0.4)
  for n=1,rings-1,1 do
    local num_holes = crawl.random2(n+1) + 1 + crawl.random2(n)
    ring_holes[n] = { num = num_holes,
                      offset = util.random_range_real(0,1),
                      phase = util.random_range_real(0.1,0.9)/num_holes,
                      size = hole_size/num_holes } -- (n/2+.5) }
  end
  local fill_center = crawl.coinflip()
  local fphase = function(x,y)
    local r = fcircle(x,y)
    if r >= 1 then return 0 end
    local rr = r * rings
    local level = math.floor(rr)
    r = rr - level
    if fill_center and level == 0 then return 1 end
    -- Fill connecting walls?
    if level > 0 and r <= wall_break then
      local p = frad(x,y)
      local hole = ring_holes[level]
      if hole ~= nil then
        p = p / hole.phase
        local fp = math.floor(p)
        if fp > 0 and fp <= (hole.num) and (p-fp) < hole.size then return 1 end
      end
    end
    return r
  end

  -- Quickly, add a bar
  -- fphase = procedural.add(fphase,procedural.bar { horizontal = true, position = gym/2, width = 5 })

  if you.in_branch("Snake") then

    -- Apply distortion
    -- TODO: This whole distortion function is pretty awesome and needs to be in a library
    local fdsx = procedural.simplex3d { scale = util.random_range_real(0.1,1), unit = false }
    local fdsy = procedural.simplex3d { scale = util.random_range_real(0.1,1), unit = false }
    -- Distort more at the edge of the map
    -- TODO: Will work even better with a more generous easing function
    local fbox = procedural.box{}
    local fedge = function(x,y)
      return math.max(0,1-fbox(x,y))
    end
    local fdx = procedural.mul(fdsx,fedge)
    local fdy = procedural.mul(fdsy,fedge)

    fphase = procedural.distort { source = fphase, scale = crawl.random_range(5,15), offsetx = fdx, offsety = fdy }

  end

  procedural.render_map(_G, fphase, function(v) return (v > wall_break and '.' or 'x') end)

  zonify.map_fill_zones(_G, 1, 'x')
}}
MAP
ENDMAP

NAME:   layout_ring_interference
DEPTH:  Zot,Snake
WEIGHT: 20000
ORIENT: encompass
TAGS: overwritable layout allow_dup unrand
{{

  -- TODO: * 50% of the time this layout looks great. But often we end up with very long unbroken corridors and
  -- there should be some semblance of the hole carving algorithm from the first version.
  -- * Secondly, the negative interference produces some of the best layouts. But also it can break connectivity
  -- so we end up with tiny levels.
  -- * Might be nice to try 3 or 4 things interfering (how would this work with negatives?)

  layout_type "halls"
  if is_validating() then return; end
  local gxm,gym = dgn.max_bounds()

  local fcircle
  if crawl.coinflip() then
    fcircle = procedural.distance { radius = math.min(gxm,gym)/2.5 - 2, origin = { x = gxm/2, y = gym/2 } }
  else
    local padx,pady = crawl.random_range(2,10),crawl.random_range(2,10)
    fcircle = procedural.box { x1 = padx, y1 = pady, x2 = gxm-1-padx, y2 = gym-1-pady }
  end

  local wall_break = util.random_range_real(.4,.6)
  local rings = crawl.random_range(4,8)

  local fill_center = crawl.coinflip()
  local frings = function(x,y)
    local r = fcircle(x,y)
    if r >= 1 then return 0 end
    local rr = r * rings
    local level = math.floor(rr)
    r = rr - level
    if fill_center and level == 0 then return 1 end
    return r
  end

  if you.in_branch("Snake") then

    -- Apply distortion
    local fdsx = procedural.simplex3d { scale = util.random_range_real(0.1,1), unit = false }
    local fdsy = procedural.simplex3d { scale = util.random_range_real(0.1,1), unit = false }
    -- Distort more at the edge of the map
    local fbox = procedural.box{}
    local fedge = function(x,y)
      return math.max(0,1-fbox(x,y))
    end
    local fdx = procedural.mul(fdsx,fedge)
    local fdy = procedural.mul(fdsy,fedge)

    frings = procedural.distort { source = frings, scale = crawl.random_range(5,15), offsetx = fdx, offsety = fdy }

  end

  -- Generate the interference pattern by combining two coords
  -- from the original func
  local xor = crawl.coinflip()
  local dir = util.random_from(vector.directions)
  local dist = crawl.random_range(4,8)
  local offx,offy = dist*dir.x,dist*dir.y
  local fphase = function(x,y)
    local r1 = frings(x-offx,y-offy)
    local r2 = frings(x+offx,y+offy)
    if xor and r1>wall_break and r2>wall_break then
      return r1-r2
    else
      return math.max(r1,r2)
    end
  end

  procedural.render_map(_G, fphase, function(v) return (v > wall_break and '.' or 'x') end)

  zonify.map_fill_zones(_G, 1, 'x')
}}
MAP
ENDMAP
