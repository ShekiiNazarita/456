################################################################################
# Layouts for The Vaults (mumra's rewrite)
#
# This file contains map headers for picking the main layout. It mainly calls
# off to functions which are held in dlua/v_layouts.lua. The idea is that
# layout parameters (and importantly DEPTH, WEIGHT, etc.) can be easily tweaked
# in this header and all building logic happens in pure *.lua files.
#
# It uses all the mini vaults from layout_vaults_*.des and places these as
# rooms within structured areas. These vaults can use various to
# modify the way they are used within the layouts. A vault requires at least
# one of the following to even be used:
#
# - vaults_room
#     A standard room. These are the most commonly used type and therefore will
#     be seen a lot.
#     As such they should used standard monster/item placement (8s, 9s, etc.),
#     be extremely sparing with any obvious layout features, and be heavily
#     randomised.
#
# - vaults_rare
#     Rare rooms. These are more like normal branch minivaults. They can contain
#     more interesting features and they might
#
# - vaults_empty
#     Empty rooms. These provide furniture for areas that we otherwise want empty.
#     They should allow normal monster placement.
#
# - vaults_stairs_up
# - vaults_stairs_down
#     Up to three each will be placed of these room types. It is assumed
#     that the room has one staircase (and most should). If it does have more
#     you can include the tag layout_vaults_stairs_2 or layout_vaults_stairs_3
#     and set a low weight.
#     The builder will place rooms until it has enough stairs. Down stairs
#     will usually place 3 and only rarely 2 or 1, never on V:$-1. Up stairs
#     are less strict (and therefore more likely to ultimately be placed
#     in the corridors).
#
# In addition there are some specific modifier tags:
#
# - vaults_no_windows
#     The vault will never have windows.
#
# - vaults_orient_n
# - vaults_orient_e
# - vaults_orient_s
# - vaults_orient_w
#     Controls the orientation of the vault. A vault can have multiple of these
#     tags if it designed to be entered from multiple directions, in which case a
#     random orientation will be picked from the ones you have specified. If it
#     has none of these tags then it will be randomly rotated.
#     Specifically the tags mean "the vault can be entered from this direction".
#     It doesn't mean your vault won't be rotated, it just means that the door
#     will be placed at the correct size as you've designed it. So if you have
#     vaults_orient_n, but the vault is placed rotated 90 degrees clockwise, then
#     the door will be at the west.
#     These tags also control how additional sub-rooms might get attached onto
#     your room. If you have vaults_orient_n and vaults_orient_s then your vault
#     could get used as a corridor connecting one part of the layout to another
#     room.
#
# TODO: Should the documentation above be moved to a text file in docs or even
#       to general vault authoring docmentation? -mumra

default-depth: Vaults

# Include layout code
: require("dlua/v_layouts.lua")

################################################################################
# Ring Layout
#
# A square corridor with rooms around the edge and in the center. It is possible
# to lose
#
# The layouts all require no mirror or rotate, otherwise this messes with
# placement of the sub vaults, since we have to be quite specific with where
# we want them and how they are placed. This doesn't matter, because the
# layouts are built in a way that is already symmetrically random.
#
# We call parameterised functions to build the levels. This means we can vary
# the parameters with different DEPTH or WEIGHT settings to make certain
# layout styles more or less likely.
NAME: layout_vaults_ring
DEPTH: Vaults
WEIGHT: 25
ORIENT: encompass
CHANCE: 100%
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror chance_vaults
: build_vaults_ring_layout(_G, 5, 20)
MAP
ENDMAP

################################################################################
# Omnibox
#
# This will generate anything from chaotic city to maze (thru "square ring
# huge center" / "square ring chaotic city") and more!
#
# Apologies if this is just too little code.
NAME: layout_vaults_omnibox
DEPTH: Vaults
WEIGHT: 70
ORIENT: encompass
CHANCE: 100%
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror chance_vaults
{{
  local gxm,gym = dgn.max_bounds()
  local min_size = 6
  local p1 = { x = crawl.random_range(1,gxm - 1 - min_size), y = crawl.random_range(1,gym - 1 - min_size) }
  local p2 = { x = crawl.random_range(p1.x + min_size - 1, gxm - 1), y = crawl.random_range(p1.y + min_size - 1, gym - 1) }
  build_vaults_layout(_G, "Omnibox", { { type = "floor", corner1 = p1, corner2 = p2 } })
}}
MAP
ENDMAP

################################################################################
# Omnicross
#
# Generates junctions of various kinds, including big crosses, t-junctions, and
# corners (potentially thick enough for cities in the middle) and more!
NAME: layout_vaults_omnicross
DEPTH: Vaults
WEIGHT: 70
ORIENT: encompass
CHANCE: 100%
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror chance_vaults
{{
  local gxm,gym = dgn.max_bounds()
  -- Corridor widths
  local min_width,max_width = 4,20
  local width1,width2 = crawl.random_range(min_width,max_width),crawl.random_range(min_width,max_width)
  -- Positions along either axis
  local pos1,pos2 = crawl.random_range(1,gym-2-width1),crawl.random_range(1,gxm-2-width2)
  -- Corridor lengths
  local length1,length2 = crawl.random_range((gxm+1)/2,gxm-2),crawl.random_range((gym+1)/2,gym-2)
  -- Intersect positions
  local inter1,inter2 = crawl.random_range(math.max(1,pos2-length1+width2),math.min(gxm-1-length1,pos2)),crawl.random_range(math.max(1,pos1-length2+width1),math.min(gym-1-length2,pos1))

  build_vaults_layout(_G, "Omnicross", {
    { type = "floor", corner1 = { x = inter1, y = pos1 }, corner2 = { x = inter1 + length1 - 1, y = pos1 + width1 - 1 } },
    { type = "floor", corner1 = { x = pos2, y = inter2 }, corner2 = { x = pos2 + width2 - 1, y = inter2 + length2 - 1 } },
  })
}}
MAP
ENDMAP

################################################################################
# Grid
#
# Basically like V:5 except it might be divided into smaller areas than quadrants
NAME: layout_vaults_quadrants
DEPTH: Vaults
WEIGHT: 1000
ORIENT: encompass
CHANCE: 100%
{{
  local gxm,gym = dgn.max_bounds()
  local paint = { { type = "floor", corner1 = { x = 1, y = 1 }, corner2 = { x = gxm-2, y = gym-2 } } }
  local pad = 2
  local bisectx = crawl.random_range(2,4)
  local bisecty = crawl.random_range(2,4)
  for i = 0, (bisectx-1), 1 do
    for j = 0, (bisecty-1), 1 do
      table.insert(paint, { type = "wall",
        corner1 = { x = 1 + math.floor((gxm - 2) / bisectx ) * i + pad, y = 1 + math.floor((gym - 2) / bisecty) * j + pad },
        corner2 = { x = 1 + math.floor((gxm - 2) / bisectx ) * (i+1) - pad - 1, y = 1 + math.floor((gym - 2) / bisecty) * (j+1) - pad - 1 }
      })
    end
  end

  build_vaults_layout(_G, "Quadrants", paint)
}}
MAP
ENDMAP

################################################################################
# Omnicross
#
# Generates junctions of various kinds, including big crosses, t-junctions, and
# corners (potentially thick enough for cities in the middle) and more!
NAME: layout_vaults_omnicrossx
DEPTH: Vaults
WEIGHT: 0
ORIENT: encompass
CHANCE: 100%
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror chance_vaults
{{
  local gxm,gym = dgn.max_bounds()
  -- Corridor widths
  local min_width,max_width = 4,20
  local width1,width2 = crawl.random_range(min_width,max_width),crawl.random_range(min_width,max_width)
  local half_size = { x = math.ceil(width1/2), y = math.ceil(width2/2) }
  -- Corridor lengths
  local length1,length2 = crawl.random_range((gxm+1)/2,gxm-2),crawl.random_range((gym+1)/2,gym-2)
  -- Where on the map they intersect
  local intersect = { x = crawl.random_range(2+half_size.y, gxm - 2 - half_size.y), y = crawl.random_range(2+(half_size.x), gym - 2 - half_size.y) }
  -- How each corridor is positioned along the intersect
  local pos1,pos2 = crawl.random_range(0, gxm - 2 - length1 - width2), crawl.random_range(0, gym - 2 - length2 - width1)
  -- Calculate the two boxes
  local p1 = { x = intersect.x + half_size.y - length1 + pos1, y = intersect.y - half_size.x }
  local p2 = { x = p1.x + length1, y = p1.y + width2 }
  local p3 = { x = intersect.x - half_size.y, y = intersect.y + half_size.x - length2 + pos2 }
  local p4 = { x = p3.x + width1, y = p3.y + length2 }

  build_vaults_layout(_G, "Omnicross", {
    { type = "floor", corner1 = p1, corner2 = p2 },
    { type = "floor", corner1 = p3, corner2 = p4 }
  })
}}
MAP
ENDMAP

NAME: layout_vaults_big_room
DEPTH: Vaults
WEIGHT: 50
ORIENT: encompass
CHANCE: 100%
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror chance_vaults
: build_vaults_big_room_layout(_G, 20)
MAP
ENDMAP

NAME: layout_vaults_chaotic_city
DEPTH: Vaults
WEIGHT: 10
ORIENT: encompass
CHANCE: 100%
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror chance_vaults
: build_vaults_chaotic_city_layout(_G, 5, 0.5)
MAP
ENDMAP

NAME: layout_vaults_maze
DEPTH: Vaults
WEIGHT: 80
ORIENT: encompass
CHANCE: 100%
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror chance_vaults
: build_vaults_maze_layout(_G)
MAP
ENDMAP

NAME: layout_vaults_maze_snakey
DEPTH: Vaults
WEIGHT: 30
ORIENT: encompass
CHANCE: 100%
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror chance_vaults
: build_vaults_maze_snakey_layout(_G)
MAP
ENDMAP

NAME: layout_vaults_maze_bifur
DEPTH: Vaults
WEIGHT: 30
ORIENT: encompass
CHANCE: 100%
TAGS: overwritable layout allow_dup unrand no_rotate no_pool_fixup no_hmirror no_vmirror chance_vaults
: build_vaults_maze_bifur_layout(_G)
MAP
ENDMAP
