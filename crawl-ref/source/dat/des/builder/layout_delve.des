###############################################################################
# layout_geoelf.des: Layouts buit around the delve command
###############################################################################

: require("dlua/layout/zonify.lua")
: require("dlua/layout/theme.lua")
: require("dlua/layout/minimum_map_area.lua")


##############################################################
# layout_twisted_cavern
#
# A long winding cavern of roughly constant width, snaking around all the
# level.  It forks from time to time, but never for long.
#
# TODO: Rework and add at weight 5.  Possible ideas on devwiki.
#
NAME: layout_twisted_cavern
DEPTH: D:4-, Depths
WEIGHT: 0
ORIENT: encompass
TAGS:   overwritable layout allow_dup unrand layout_type_narrow_caves
{{
    if is_validating() then return; end

    local gxm, gym = dgn.max_bounds()
    extend_map{width = gxm, height = gym}
    fill_area{fill = 'x', border = 'X'}

    delve(3, 3, 0, -1, 1)
    subst('X = x')

    theme.D.caves_classic(_G)
}}

##############################################################
# layout_spider_delve
#
# Previously named "layout_delve".
#
# TODO: Use "layout_type_narrow_caves" tag for passage-y version
#       and "layout_type_open_caves" tag for more open version.
#
NAME:   layout_spider_delve
DEPTH:  Spider
WEIGHT: 25
ORIENT: encompass
TAGS:   overwritable layout allow_dup unrand layout_type_narrow_caves
{{
    if is_validating() then return; end

    local gxm, gym = dgn.max_bounds()
    extend_map{width = gxm, height = gym}
    fill_area{fill = 'x', border = 'X'}

    local ngb_min = 2
    local ngb_max = crawl.random_range(3, 8)
    if crawl.one_chance_in(10) then
      -- sometimes use a more cramped layout
      ngb_min = 1
      ngb_max = crawl.random_range(5, 7)
    end
    if crawl.one_chance_in(20) then
      -- or a wider one
      ngb_min = 3
      ngb_max = 4
    end
    local connchance = crawl.random_element
        { [0] = 2, [5] = 1, [20] = 1, [50] = 1, [100] = 1 }
    local top = crawl.random_element
        { [1] = 1, [20] = 1, [125] = 1, [500] = 1, [999999] =1 }
    crawl.dpr("<lightmagenta>delve(" .. ngb_min .. ", " .. ngb_max .. ", " ..
              connchance .. ", -1, " .. top .. ")</lightmagenta>")
    delve(ngb_min, ngb_max, connchance, -1, top)
    if crawl.coinflip() then
      crawl.dpr("delve: adding water");
      subst('. = @')
      delve(ngb_min, ngb_max, 100, 100, top)
      subst('. = w')
      subst('@ = .')
    end
    subst('X = x')
}}

################################################################
# layout_cocytus_delve
#
# Previously named "layout_cocytus".
#
# An ice cave approximation for Cocytus.  There is one main
# delved path that is guaranteed to contain at least one up and
# down stairs.  There are also other delved paths and
# diamond-shaped rooms, but these might be behind pools of
# water.  To avoid trapping the player, all random teleports go
# to the main path.
#
# TODO: Serious improvements, less glyph switching
#
NAME:   layout_cocytus_delve
DEPTH:  Coc
WEIGHT: 10
ORIENT: encompass
TAGS:   overwritable layout allow_dup unrand layout_type_narrow_caves
TAGS:   no_rotate no_vmirror no_hmirror
{{
    if is_validating() then return; end

    local gxm, gym = dgn.max_bounds()
    extend_map{width = gxm, height = gym}

    local map_border = 5
    local map_x_min = map_border
    local map_y_min = map_border
    local map_x_max = gxm - map_border - 1
    local map_y_max = gym - map_border - 1
    fill_area { x1 = map_x_min, y1 = map_y_min,
                x2 = map_x_max, y2 = map_y_max, fill = 'x', border = 'X' }

    -- Due to the behaviour of the spotty_map, delve, and
    --  fill_disconnected functions, we need to make some
    --  strange substitutions to have the right glyphs on the
    --  map when we call these functions.  We will put the
    --  glyphs right again later.
    --    -> spotty_map always expands '.' glyphs with '.'s
    --    -> delve always places '.' glyphs and seems to have
    --       trouble with 'w's
    --    -> fill_disconnected will not fill custom-defined
    --       glyphs, even if they are kfeat-ed to another glyph

    -- Add some water patches.
    --    1. Add some circles of floor
    --    2. Expand the floor circles using spotty_map
    --    3. Convert the floor to unbreakable wall (later water)
    for i = 1, crawl.random_range(40, 60) do
        local x = crawl.random_range(map_x_min, map_x_max)
        local y = crawl.random_range(map_y_min, map_y_max)
        local radius = crawl.random_range(0, 1)
        if crawl.one_chance_in(15) then
            radius = crawl.random_range(2, 4)
        end

        make_circle ({ x = x, y = y, radius = radius, fill = '.'})
    end
    local iterations = crawl.random_range(150, 350)
    spotty_map { boxy = false, iterations = iterations }
    subst('. = X')

    -- Delve the paths
    local ngb_min = 2
    local ngb_max = 5
    -- chance of connecting to an adjecent passage
    local connchance = 0
    local total_count = crawl.random_range(200, 500)
    local top = 10

    -- Delve the main path and add two sets of stairs.  This
    --  guarantees the map is connected without crossing water.
    --  Keep the '@' glyph for connectivity checking later.
    delve(ngb_min, ngb_max, connchance, total_count, top)
    nsubst('. = 1:@ / *:.')
    local x, y = farthest_from('@')
    mapgrd[x][y] = '{'
    x, y = farthest_from('{')
    mapgrd[x][y] = '}'
    subst('. = >')

    -- Delve some smaller paths
    for i = 1, crawl.random_range(1, 3) do
        ngb_min = crawl.random_element { [1] = 3, [2] = 1 }
        ngb_max = crawl.random_range(2, 5)
        connchance = crawl.random_element
            { [0] = 1, [2] = 2, [5] = 1, [20] = 1 }
        total_count = crawl.random_range(50, 150)
        top = crawl.random_element
            { [1] = 1, [20] = 1, [125] = 1, [500] = 1, [999999] = 1 }

        delve(2, 3, 3, 150, 100)
    end
    subst('. = <')

    -- Fix up the map after delving.
    --    1. The edges become walls
    --    2. The remaining unbreakable walls become water
    fill_area { x1 = 0,         y1 = 0,
                x2 = map_x_min, y2 = gym-1,     fill = 'x' }
    fill_area { x1 = map_x_max, y1 = 0,
                x2 = gxm-1,     y2 = gym-1,     fill = 'x' }
    fill_area { x1 = map_x_min, y1 = 0,
                x2 = map_x_max, y2 = map_y_min, fill = 'x' }
    fill_area { x1 = map_x_min, y1 = map_y_max,
                x2 = map_x_max, y2 = gym-1,     fill = 'x' }
    subst('X = w')

    -- Add some rooms
    for i = 1, crawl.random_range(15, 25) do
        local x = crawl.random_range(8, gxm-9)
        local y = crawl.random_range(8, gym-9)
        local radius = crawl.random_element
            { [1] = 30, [2] = 50, [3] = 15, [4] = 4, [5] = 1 }

        octa_room { x1 = x - radius, y1 = y - radius,
                    x2 = x + radius, y2 = y + radius,
                    oblique = radius, replace = 'x', inside = '<'}
    end

    -- Finishing up stuff.
    --     1. Fill everything not connected to the '@' set when
    --        delving the first path.
    --     2. Set the first delved path to floor.
    --     3. Set the rooms and the other delved paths to
    --        no_r_tele_into floor ('_').  These areas might be
    --        inescapable if water covers the path out.
    fill_disconnected{wanted = '@'}
    subst('@> = .')
    subst('< = _')
    kfeat('_ = .')
    kprop('_ = no_rtele_into')
}}
